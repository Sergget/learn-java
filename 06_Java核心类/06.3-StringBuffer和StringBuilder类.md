# 6.3 Java StringBuffer 和 StringBuilder 类
当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

```java
public class Test{
  public static void main(String args[]){
    StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");
    sBuffer.append("www");
    sBuffer.append(".runoob");
    sBuffer.append(".com");
    System.out.println(sBuffer);  
  }
}
```
以上实例编译运行结果如下：

>菜鸟教程官网：www.runoob.com

## 6.3.1 StringBuilder类

一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。

> StringBuilder MyStringBuilder = new StringBuilder("Hello World!");

常用方法：
|序号|方法|描述|
|-|-|-|
|1|append(String obj)|用来将字符串添加到StringBuilder对象的结尾处|
|2|Insert(int, String)|将字符串或对象添加到当前 StringBuilder中的指定位置|
|3|delete(int start, int end)|移除指定数量的字符|
|4|replace(int start, int end,String str)|用另一个指定的字符来替换 StringBuilder对象内的字符|
|5|reverse()|将源字符串倒序|

如果程序对附加字符串的需求很频繁，不建议使用+来进行字符串的串联。可以考虑使用java.lang.StringBuilder 类，使用这个类所产生的对象默认会有16个字符的长度，也可以自行指定初始长度。如果附加的字符超出可容纳的长度，则StringBuilder 对象会自动增加长度以容纳被附加的字符。如果有频繁作字符串附加的需求，使用StringBuilder 类能使效率大大提高。如下代码：

```java
public class AppendStringTest  
{  
  public static void main(String[] args)  
    {  
      String text = "" ;  

      long beginTime = System.currentTimeMillis();  
      for ( int i= 0 ;i< 10000 ;i++)  
              text = text + i;  
      long endTime = System.currentTimeMillis();  
      System.out.println("执行时间：" +(endTime-beginTime));  

      StringBuilder sb = new StringBuilder ( "" );  
      beginTime = System.currentTimeMillis();  
      for ( int i= 0 ;i< 10000 ;i++)  
              sb.append(String.valueOf(i));  
      endTime = System.currentTimeMillis();  
      System.out.println("执行时间：" +(endTime-beginTime));  
    }  
}  
```

此段代码输出：
>执行时间：119\
>执行时间：2

## 6.3.2 StringBuffer 方法
以下是 StringBuffer 类支持的主要方法：

|序号|方法|描述|
|-|-|-|
|1|public StringBuffer append(String s)|将指定的字符串追加到此字符序列。|
|2|public StringBuffer reverse() |将此字符序列用其反转形式取代。|
|3|public delete(int start, int end)| 移除此序列的子字符串中的字符。|
|4|public insert(int offset, int i) |将 int 参数的字符串表示形式插入此序列中。|
|5|replace(int start, int end, String str)| 使用给定 String 中的字符替换此序列的子字符串中的字符。|

下面的列表里的方法和 String 类的方法类似：

|序号|方法|描述|
|-|-|-|
|1	|int capacity() |返回当前容量。|
|2	|char charAt(int index) |返回此序列中指定索引处的 char 值。|
|3	|void ensureCapacity(int minimumCapacity) |确保容量至少等于指定的最小值。|
|4	|void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) |将字符从此序列复制到目标字符数组 dst。|
|5	|int indexOf(String str) |返回第一次出现的指定子字符串在该字符串中的索引。|
|6	|int indexOf(String str, int fromIndex) |从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。|
|7	|int lastIndexOf(String str) |返回最右边出现的指定子字符串在此字符串中的索引。|
|8	|int lastIndexOf(String str, int fromIndex) |返回 String 对象中子字符串最后出现的位置。|
|9	|int length() | 返回长度（字符数）。|
|10|	void setCharAt(int index, char ch) |将给定索引处的字符设置为 ch。|
|11|	void setLength(int newLength) |设置字符序列的长度。|
|12|	CharSequence subSequence(int start, int end) |返回一个新的字符序列，该字符序列是此序列的子序列。|
|13|	String substring(int start) |返回一个新的 String，它包含此字符序列当前所包含的字符子序列。|
|14|	String substring(int start, int end) |返回一个新的 String，它包含此序列当前所包含的字符子序列。|
|15|	String toString() |返回此序列中数据的字符串表示形式。|

## 6.3.3 Java：String、StringBuffer 和 StringBuilder

### 区别
- `String`：字符串常量，字符串长度不可变。Java中String 是immutable（不可变）的。用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。
- `StringBuffer`：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。Java.lang.StringBuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。
- `StringBuilder`：字符串变量（非线程安全）。在内部 StringBuilder 对象被当作是一个包含字符序列的变长数组。

### 基本原则：

- 如果要操作少量的数据用 String ；
- 单线程操作大量数据用StringBuilder ；
- 多线程操作大量数据，用StringBuffer。

### StringBuilder 和 StringBuffer适用的场景
最简单的回答是，**stringbuffer 基本没有适用场景，你应该在所有的情况下选择使用 stringbuiler**，除非你真的遇到了一个需要线程安全的场景，如果遇到了，请务必在这里留言通知我。

然后，补充一点，关于线程安全，即使你真的遇到了这样的场景，很不幸的是，恐怕你仍然有 99.99....99% 的情况下没有必要选择 stringbuffer，因为 stringbuffer 的线程安全，仅仅是保证 jvm 不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。

最后，为什么会有 stringbuffer 的存在，如果真的没有价值，为什么 jdk 会提供这个类？答案太简单了，因为最早是没有 stringbuilder 的，sun 的人不知处于何种愚蠢的考虑，决定让 stringbuffer 是线程安全的，然后大约 10 年之后，人们终于意识到这是一个多么愚蠢的决定，意识到在这 10 年之中这个愚蠢的决定为 java 运行速度慢这样的流言贡献了多大的力量，于是，在 jdk1.5 的时候，终于决定提供一个非线程安全的 stringbuffer 实现，并命名为 stringbuilder。顺便，javac 好像大概也是从这个版本开始，把所有用加号连接的 string 运算都隐式的改写成 stringbuilder，也就是说，从 jdk1.5 开始，用加号拼接字符串已经没有任何性能损失了。

如诸多评论所指出的，我上面说，"用加号拼接字符串已经没有任何性能损失了"并不严谨，严格的说，如果没有循环的情况下，单行用加号拼接字符串是没有性能损失的，java 编译器会隐式的替换成 stringbuilder，但在有循环的情况下，编译器没法做到足够智能的替换，仍然会有不必要的性能损耗，因此，用循环拼接字符串的时候，还是老老实实的用 stringbuilder 吧。

## 6.3.4 StringJoiner

要高效拼接字符串，应该使用`StringBuilder`。

很多时候，我们拼接的字符串像这样：

```java
// Hello Bob, Alice, Grace!
public class Main {
    public static void main(String[] args) {
        String[] names = {"Bob", "Alice", "Grace"};
        var sb = new StringBuilder();
        sb.append("Hello ");
        for (String name : names) {
            sb.append(name).append(", ");
        }
        // 注意去掉最后的", ":
        sb.delete(sb.length() - 2, sb.length());
        sb.append("!");
        System.out.println(sb.toString());
    }
}
```

用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事：

```java
import java.util.StringJoiner;
public class Main {
  public static void main(String[] args) {
    String[] names = {"Bob", "Alice", "Grace"};
    var sj = new StringJoiner(", ");
    for (String name : names) {
        sj.add(name);
    }
    System.out.println(sj.toString());
  }
}
```

慢着！用StringJoiner的结果少了前面的"Hello "和结尾的"!"！遇到这种情况，需要给StringJoiner指定“开头”和“结尾”：

```java
import java.util.StringJoiner;
public class Main {
  public static void main(String[] args) {
    String[] names = {"Bob", "Alice", "Grace"};
    var sj = new StringJoiner(", ", "Hello ", "!");
    for (String name : names) {
        sj.add(name);
    }
    System.out.println(sj.toString());
  }
}
```

那么`StringJoiner`内部是如何拼接字符串的呢？如果查看源码，可以发现，StringJoiner内部实际上就是使用了`StringBuilder`，所以拼接效率和`StringBuilder`几乎是一模一样的。

### String.join()
String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用`String.join()`更方便：

```java
String[] names = {"Bob", "Alice", "Grace"};
var s = String.join(", ", names);
```